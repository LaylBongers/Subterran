<#@ IntelliSenseLanguage processor="tangibleT4Editor" language="C#" #>
<#+

// Creates a new Vector2-style struct
void Vector2Struct(string name, string type, string[] allowedAdditions)
{#>
	public struct <#= name #> : IEquatable<<#= name #>>
	{
		public static readonly <#= name #> Zero = new <#= name #>();

		private readonly <#= type #> _x;
		private readonly <#= type #> _y;

		public <#= name #>(<#= type #> x, <#= type #> y)
		{
			_x = x;
			_y = y;
		}

		public <#= type #> X { get { return _x; } }
		public <#= type #> Y { get { return _y; } }

<#+	
	foreach (var addition in allowedAdditions)
	{
#>
		public static <#= name #> operator +(<#= name #> left, <#= addition #> right)
		{
			return new <#= name #>(left.X + right.X, left.Y + right.Y);
		}
<#+
	}
#>
		
		public bool Equals(<#= name #> other)
		{
			return _x.Equals(other._x) && _y.Equals(other._y);
		}

		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			return obj is <#= name #> && Equals((<#= name #>) obj);
		}

		public override int GetHashCode()
		{
			unchecked
			{
				return (_x*397) ^ _y;
			}
		}

		public static bool operator ==(<#= name #> left, <#= name #> right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(<#= name #> left, <#= name #> right)
		{
			return !left.Equals(right);
		}
	}
<#+
}

// Creates a new Vector3-style struct
void Vector3Struct(string name, string type, string[] allowedAdditions)
{#>
	public struct <#= name #> : IEquatable<<#= name #>>
	{
		public static readonly <#= name #> Zero = new <#= name #>();

		private readonly <#= type #> _x;
		private readonly <#= type #> _y;
		private readonly <#= type #> _z;

		public <#= name #>(<#= type #> x, <#= type #> y, <#= type #> z)
		{
			_x = x;
			_y = y;
			_z = z;
		}

		public <#= type #> X { get { return _x; } }
		public <#= type #> Y { get { return _y; } }
		public <#= type #> Z { get { return _z; } }

		// Scales the <#= name #> to the given amount.
		public static <#= name #> operator *(<#= name #> left, <#= type #> right)
		{
			return new <#= name #>(left.X * right, left.Y * right, left.Z * right);
		} 

<#+	
	foreach (var addition in allowedAdditions)
	{
#>
		public static <#= name #> operator +(<#= name #> left, <#= addition #> right)
		{
			return new <#= name #>(left.X + right.X, left.Y + right.Y, left.Z + right.Z);
		}
<#+
	}
#>
		
		public bool Equals(<#= name #> other)
		{
			return _x.Equals(other._x) && _y.Equals(other._y) && _z.Equals(other._z);
		}

		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			return obj is <#= name #> && Equals((<#= name #>) obj);
		}

		public override int GetHashCode()
		{
			unchecked
			{
				int hashCode = _x.GetHashCode();
				hashCode = (hashCode*397) ^ _y.GetHashCode();
				hashCode = (hashCode*397) ^ _z.GetHashCode();
				return hashCode;
			}
		}

		public static bool operator ==(<#= name #> left, <#= name #> right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(<#= name #> left, <#= name #> right)
		{
			return !left.Equals(right);
		}
	}
<#+
}
#>